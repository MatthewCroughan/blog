<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Matthew Croughan's Blog</title><link>https://blog.croughan.sh/</link><description>Recent content on Matthew Croughan's Blog</description><generator>Hugo -- gohugo.io</generator><language>en-us</language><lastBuildDate>Thu, 06 Jan 2022 00:00:00 +0000</lastBuildDate><atom:link href="https://blog.croughan.sh/index.xml" rel="self" type="application/rss+xml"/><item><title>Godot's Export to Android: Easy with Nix</title><link>https://blog.croughan.sh/posts/godot-automation-nixos/</link><pubDate>Thu, 06 Jan 2022 00:00:00 +0000</pubDate><guid>https://blog.croughan.sh/posts/godot-automation-nixos/</guid><description>The pain Reading the Exporting for Android documentation for Godot is grim. It instructs developers to manually execute series of esoteric runes in order to hopefully achieve an end result and environment that is the same as everyone else. It expects you, the user, to &amp;ldquo;Ensure that the required packages are installed as well.&amp;rdquo;, at specific versions. It does not tell you how to go about getting those versions of the required programs, whilst encouraging you to use sdkmanager, a constantly mutating script which downloads random files and binaries from the internet, compiling nothing from source, and leaving two developers in very different states.</description><content>&lt;h1 id="the-pain">The pain&lt;/h1>
&lt;p>Reading the &lt;a href="https://docs.godotengine.org/en/3.4/tutorials/export/exporting_for_android.html#exporting-for-android">Exporting for
Android&lt;/a>
documentation for Godot is grim. It instructs developers to manually execute
series of esoteric runes in order to &lt;em>hopefully&lt;/em> achieve an end result and
environment that is the same as everyone else. It expects you, the user, to
&amp;ldquo;Ensure that the required packages are installed as well.&amp;rdquo;, at specific
versions. It does not tell you how to go about getting those versions of the
required programs, whilst encouraging you to use &lt;code>sdkmanager&lt;/code>, a constantly
mutating script which downloads random files and binaries from the internet,
compiling nothing from source, and leaving two developers in very different
states.&lt;/p>
&lt;p>After the developer has built their environment using &lt;a href="https://www.youtube.com/watch?v=H4oHU3RXjiM">nothing but a box of
scraps&lt;/a>, they&amp;rsquo;re expected to do
even more:&lt;/p>
&lt;p>Now, they must:&lt;/p>
&lt;ul>
&lt;li>
&lt;p>Fill in strings by hand via the Godot GUI, which modifies the state of
the &lt;code>~/.config/godot/editor_settings-3.tres&lt;/code> file, something unique to their
system.&lt;/p>
&lt;/li>
&lt;li>
&lt;p>Allow Godot to download files from the internet and place precompiled
static binaries known as [export templates] from the internet, placing them in
&lt;code>~/.local/share/godot/templates/&lt;/code> and put it into&lt;/p>
&lt;/li>
&lt;li>
&lt;p>Generate an Android debug keystore, for deploying to a development device&lt;/p>
&lt;/li>
&lt;/ul>
&lt;p>Each step is required if you want to export your Godot game for Android. If you
miss a step or perform it in the wrong order, you risk hours of debugging. Do
developers really have to go through all of this trouble, just to achieve the
simple goal of exporting for Android? Can&amp;rsquo;t some sort of system handle this for
us?&lt;/p>
&lt;h1 id="patching-godot-to-pieces">Patching Godot to pieces&lt;/h1>
&lt;p>&lt;a href="https://github.com/goatchurchprime/">Julian Todd&lt;/a>, makes a project called
&lt;a href="https://github.com/tunnelvr/tunnelvr">TunnelVR&lt;/a>, which is aiming to be like
OpenStreetMaps for caves. He needs Android export capabilities, and I don&amp;rsquo;t want
him to go through the pain explained above.&lt;/p>
&lt;p>I want him to be able to run a single command in order to obtain an environment
in which everything is present and already wired into Godot, this means:&lt;/p>
&lt;ul>
&lt;li>The Android SDK, without needing to run a series of random &lt;code>sdkmanager&lt;/code>
commands.&lt;/li>
&lt;li>The Godot Export Templates, without needing to click any
buttons in Godot.&lt;/li>
&lt;li>A debug android keystore, without needing to manually generate keys using the
&lt;code>keytool&lt;/code> command.&lt;/li>
&lt;/ul>
&lt;p>If only there were a way to tell Godot where to find the Android SDK, Godot
Export Templates and Android keystore, perhaps via the cli or by an environment
variable; bypassing their &lt;code>editor_settings-3.tres&lt;/code> config file which is
constantly being overwritten as you fill in boxes in the editor. That way, I
could grab those in a way that I control, constructing an environment for a
developer in my own way, simply telling Godot where to find these files.&lt;/p>
&lt;p>I got tired of &lt;a href="https://en.wikipedia.org/wiki/Waiting_for_Godot">&lt;em>waiting for
Godot&lt;/em>&lt;/a>, so patched the source
code using &lt;a href="https://nixos.org/guides/install-nix.html">Nix&lt;/a>, to accomplish
exactly that, and was very successful. My commits and pull request are visible
&lt;a href="https://github.com/tunnelvr/tunnelvr/pull/28">here&lt;/a>, let&amp;rsquo;s take a look at what
I did.&lt;/p>
&lt;h2 id="defining-a-patched-godot">Defining a patched Godot&lt;/h2>
&lt;p>We need to make Godot read environment variables for the paths we want to
control. We can only do this by modifying Godot&amp;rsquo;s source code, but they&amp;rsquo;re
unlikely to accept a patch for this functionality.&lt;/p>
&lt;p>I define &lt;code>my-godot&lt;/code>. It is equal to the &lt;code>godot&lt;/code> we already have from Nixpkgs,
except we&amp;rsquo;re going to make a few changes. We use &lt;code>overrideAttrs&lt;/code>, a function
that lives inside of all packages in Nixpkgs. This function lets us say &amp;ldquo;I want
Godot, as already described by Nixpkgs, except I want to change the source code
used, and I wanna patch some of the code, and I want to change the version
string, etc&amp;hellip;&amp;rdquo;.&lt;/p>
&lt;div class="highlight">&lt;pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-nix" data-lang="nix">&lt;span style="color:#f92672">...&lt;/span>
my-godot &lt;span style="color:#960050;background-color:#1e0010">=&lt;/span> godot&lt;span style="color:#f92672">.&lt;/span>overrideAttrs (oldAttrs: &lt;span style="color:#66d9ef">rec&lt;/span> {
version &lt;span style="color:#f92672">=&lt;/span> godot-source&lt;span style="color:#f92672">.&lt;/span>rev;
src &lt;span style="color:#f92672">=&lt;/span> godot-source;
preBuild &lt;span style="color:#f92672">=&lt;/span>
&lt;span style="color:#e6db74">&amp;#39;&amp;#39;
&lt;/span>&lt;span style="color:#e6db74"> substituteInPlace platform/android/export/export_plugin.cpp \
&lt;/span>&lt;span style="color:#e6db74"> --replace &amp;#39;String sdk_path = EditorSettings::get_singleton()-&amp;gt;get(&amp;#34;export/android/android_sdk_path&amp;#34;)&amp;#39; &amp;#39;String sdk_path = std::getenv(&amp;#34;tunnelvr_ANDROID_SDK&amp;#34;)&amp;#39;
&lt;/span>&lt;span style="color:#e6db74"> substituteInPlace platform/android/export/export_plugin.cpp \
&lt;/span>&lt;span style="color:#e6db74"> --replace &amp;#39;EditorSettings::get_singleton()-&amp;gt;get(&amp;#34;export/android/debug_keystore&amp;#34;)&amp;#39; &amp;#39;std::getenv(&amp;#34;tunnelvr_DEBUG_KEY&amp;#34;)&amp;#39;
&lt;/span>&lt;span style="color:#e6db74"> substituteInPlace editor/editor_settings.cpp \
&lt;/span>&lt;span style="color:#e6db74"> --replace &amp;#39;get_data_dir().plus_file(&amp;#34;templates&amp;#34;)&amp;#39; &amp;#39;std::getenv(&amp;#34;tunnelvr_EXPORT_TEMPLATES&amp;#34;)&amp;#39;
&lt;/span>&lt;span style="color:#e6db74"> &amp;#39;&amp;#39;&lt;/span>;
});
&lt;span style="color:#f92672">...&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;p>&lt;code>substituteInPlace&lt;/code> is roughly equivalent to &lt;code>sed&lt;/code>, except all I have to say is
&amp;ldquo;Take this file and replace this string with another string.&amp;rdquo;. In this example,
I am taking the Godot C++ source code and replacing the offending code in the
relevant files with my own.&lt;/p>
&lt;p>&lt;code>EditorSettings::get_singleton()-&amp;gt;get(&amp;quot;export/android/android_sdk_path&lt;/code> means
that Godot will read my &lt;code>~/.config/godot/editor_settings-3.tres&lt;/code> to find the
value of the &lt;code>android_sdk_path&lt;/code> string that the Godot devs assume has been added
by the user. Instead, I&amp;rsquo;m going to make it equal to an environment variable I
define, &lt;code>$tunnelvr_ANDROID_SDK&lt;/code>. This means I can now set the path to the
Android SDK in any way of my choosing. I then do the same for every other path I
want to control, by replacing everything with &lt;code>std::getenv&lt;/code>, rather than their
&lt;code>EditorSettings&lt;/code> functions, or hard coded paths.&lt;/p>
&lt;p>The &lt;code>preBuild&lt;/code> phase is where I&amp;rsquo;m choosing to do the patching. This means that
prior to building the source code for Godot, our version of Godot (&lt;code>my-godot&lt;/code>)
is going to run the shell script &lt;code>substituteInPlace&lt;/code> on some source code files,
to replace strings that I want to have control over in the Godot source code.
&lt;code>substituteInPlace&lt;/code> is a shell function that&amp;rsquo;s been gifted to us by Nix, since
Godot is a derivation (nix package) that was made using the
&lt;code>stdenv.mkDerivation&lt;/code> function that almost every package in Nixpkgs is made
from. It just has this helper function inside of it, ready for us to make use
of.&lt;/p>
&lt;h2 id="defining-a-wrapped-version-of-our-patched-godot">Defining a wrapped version of our patched Godot&lt;/h2>
&lt;p>Now that we&amp;rsquo;ve made a version of Godot that will read environment variables to
find our files, we can derive yet another Godot where all those environment
variables are set before you run it. Here, I call it &lt;code>my-godot-wrapped&lt;/code>.&lt;/p>
&lt;div class="highlight">&lt;pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-nix" data-lang="nix">&lt;span style="color:#f92672">...&lt;/span>
my-godot-wrapped &lt;span style="color:#960050;background-color:#1e0010">=&lt;/span> symlinkJoin {
name &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#e6db74">&amp;#34;my-godot-with-android-sdk&amp;#34;&lt;/span>;
nativeBuildInputs &lt;span style="color:#f92672">=&lt;/span> [ final&lt;span style="color:#f92672">.&lt;/span>makeWrapper ];
paths &lt;span style="color:#f92672">=&lt;/span> [ final&lt;span style="color:#f92672">.&lt;/span>my-godot ];
postBuild &lt;span style="color:#f92672">=&lt;/span>
&lt;span style="color:#66d9ef">let&lt;/span>
&lt;span style="color:#75715e"># Godot&amp;#39;s source code has `version.py` in it, which means we&lt;/span>
&lt;span style="color:#75715e"># can parse it using regex in order to construct the link to&lt;/span>
&lt;span style="color:#75715e"># download the export templates from.&lt;/span>
version &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#66d9ef">rec&lt;/span> {
&lt;span style="color:#75715e"># Fully constructed string, example: &amp;#34;3.4&amp;#34;.&lt;/span>
string &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#e6db74">&amp;#34;&lt;/span>&lt;span style="color:#e6db74">${&lt;/span>major &lt;span style="color:#f92672">+&lt;/span> &lt;span style="color:#e6db74">&amp;#34;.&amp;#34;&lt;/span> &lt;span style="color:#f92672">+&lt;/span> minor &lt;span style="color:#f92672">+&lt;/span> (final&lt;span style="color:#f92672">.&lt;/span>lib&lt;span style="color:#f92672">.&lt;/span>optionalString (patch &lt;span style="color:#f92672">!=&lt;/span> &lt;span style="color:#e6db74">&amp;#34;&amp;#34;&lt;/span>) &lt;span style="color:#e6db74">&amp;#34;.&amp;#34;&lt;/span> &lt;span style="color:#f92672">+&lt;/span> patch)&lt;span style="color:#e6db74">}&lt;/span>&lt;span style="color:#e6db74">&amp;#34;&lt;/span>;
file &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#e6db74">&amp;#34;&lt;/span>&lt;span style="color:#e6db74">${&lt;/span>godot-source&lt;span style="color:#e6db74">}&lt;/span>&lt;span style="color:#e6db74">/version.py&amp;#34;&lt;/span>;
major &lt;span style="color:#f92672">=&lt;/span> toString (builtins&lt;span style="color:#f92672">.&lt;/span>match &lt;span style="color:#e6db74">&amp;#34;.+major = ([0-9]+).+&amp;#34;&lt;/span> (builtins&lt;span style="color:#f92672">.&lt;/span>readFile file));
minor &lt;span style="color:#f92672">=&lt;/span> toString (builtins&lt;span style="color:#f92672">.&lt;/span>match &lt;span style="color:#e6db74">&amp;#34;.+minor = ([0-9]+).+&amp;#34;&lt;/span> (builtins&lt;span style="color:#f92672">.&lt;/span>readFile file));
patch &lt;span style="color:#f92672">=&lt;/span> toString (builtins&lt;span style="color:#f92672">.&lt;/span>match &lt;span style="color:#e6db74">&amp;#34;.+patch = ([1-9]+).+&amp;#34;&lt;/span> (builtins&lt;span style="color:#f92672">.&lt;/span>readFile file));
&lt;span style="color:#75715e"># stable, rc, dev, etc.&lt;/span>
status &lt;span style="color:#f92672">=&lt;/span> toString (builtins&lt;span style="color:#f92672">.&lt;/span>match &lt;span style="color:#e6db74">&amp;#34;.+status = &lt;/span>&lt;span style="color:#ae81ff">\&amp;#34;&lt;/span>&lt;span style="color:#e6db74">([A-z]+)&lt;/span>&lt;span style="color:#ae81ff">\&amp;#34;&lt;/span>&lt;span style="color:#e6db74">.+&amp;#34;&lt;/span> (builtins&lt;span style="color:#f92672">.&lt;/span>readFile file));
};
debugKey &lt;span style="color:#f92672">=&lt;/span> final&lt;span style="color:#f92672">.&lt;/span>runCommand &lt;span style="color:#e6db74">&amp;#34;debugKey&amp;#34;&lt;/span> {} &lt;span style="color:#e6db74">&amp;#39;&amp;#39;
&lt;/span>&lt;span style="color:#e6db74"> &lt;/span>&lt;span style="color:#e6db74">${&lt;/span>final&lt;span style="color:#f92672">.&lt;/span>jre_minimal&lt;span style="color:#e6db74">}&lt;/span>&lt;span style="color:#e6db74">/bin/keytool -keyalg RSA -genkeypair -alias androiddebugkey -keypass android -keystore debug.keystore -storepass android -dname &amp;#34;CN=Android Debug,O=Android,C=US&amp;#34; -validity 9999 -deststoretype pkcs12
&lt;/span>&lt;span style="color:#e6db74"> mv debug.keystore $out
&lt;/span>&lt;span style="color:#e6db74"> &amp;#39;&amp;#39;&lt;/span>;
export-templates &lt;span style="color:#f92672">=&lt;/span> final&lt;span style="color:#f92672">.&lt;/span>fetchzip {
url &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#e6db74">&amp;#34;https://downloads.tuxfamily.org/godotengine/&lt;/span>&lt;span style="color:#e6db74">${&lt;/span>version&lt;span style="color:#f92672">.&lt;/span>string&lt;span style="color:#e6db74">}&lt;/span>&lt;span style="color:#e6db74">/Godot_v&lt;/span>&lt;span style="color:#e6db74">${&lt;/span>version&lt;span style="color:#f92672">.&lt;/span>string&lt;span style="color:#e6db74">}&lt;/span>&lt;span style="color:#e6db74">-&lt;/span>&lt;span style="color:#e6db74">${&lt;/span>version&lt;span style="color:#f92672">.&lt;/span>status&lt;span style="color:#e6db74">}&lt;/span>&lt;span style="color:#e6db74">_export_templates.tpz&amp;#34;&lt;/span>;
sha256 &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#e6db74">&amp;#34;sha256-3trC1ocgIVNWN19k6LUnZ6NhDTme+aT7RVL2XmkXzr0=&amp;#34;&lt;/span>;
&lt;span style="color:#75715e"># postFetch is necessary because the downloaded file has a&lt;/span>
&lt;span style="color:#75715e"># .tpz extension, meaning `fetchzip` cannot otherwise extract&lt;/span>
&lt;span style="color:#75715e"># it properly. Additionally, the game engine expects the&lt;/span>
&lt;span style="color:#75715e"># template path to be in a folder by the name of the current&lt;/span>
&lt;span style="color:#75715e"># version + status, like &amp;#39;3.4-stable/templates&amp;#39; for example,&lt;/span>
&lt;span style="color:#75715e"># so we accomplish that here.&lt;/span>
postFetch &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#e6db74">&amp;#39;&amp;#39;
&lt;/span>&lt;span style="color:#e6db74"> unzip $downloadedFile -d ./
&lt;/span>&lt;span style="color:#e6db74"> mkdir -p $out/templates/&lt;/span>&lt;span style="color:#e6db74">${&lt;/span>version&lt;span style="color:#f92672">.&lt;/span>string&lt;span style="color:#e6db74">}&lt;/span>&lt;span style="color:#e6db74">.&lt;/span>&lt;span style="color:#e6db74">${&lt;/span>version&lt;span style="color:#f92672">.&lt;/span>status&lt;span style="color:#e6db74">}&lt;/span>&lt;span style="color:#e6db74">
&lt;/span>&lt;span style="color:#e6db74"> mv ./templates/* $out/templates/&lt;/span>&lt;span style="color:#e6db74">${&lt;/span>version&lt;span style="color:#f92672">.&lt;/span>string&lt;span style="color:#e6db74">}&lt;/span>&lt;span style="color:#e6db74">.&lt;/span>&lt;span style="color:#e6db74">${&lt;/span>version&lt;span style="color:#f92672">.&lt;/span>status&lt;span style="color:#e6db74">}&lt;/span>&lt;span style="color:#e6db74">
&lt;/span>&lt;span style="color:#e6db74"> &amp;#39;&amp;#39;&lt;/span>;
};
&lt;span style="color:#66d9ef">in&lt;/span>
&lt;span style="color:#e6db74">&amp;#39;&amp;#39;
&lt;/span>&lt;span style="color:#e6db74"> wrapProgram $out/bin/godot \
&lt;/span>&lt;span style="color:#e6db74"> --set tunnelvr_ANDROID_SDK &amp;#34;&lt;/span>&lt;span style="color:#e6db74">${&lt;/span>final&lt;span style="color:#f92672">.&lt;/span>androidenv&lt;span style="color:#f92672">.&lt;/span>androidPkgs_9_0&lt;span style="color:#f92672">.&lt;/span>androidsdk&lt;span style="color:#e6db74">}&lt;/span>&lt;span style="color:#e6db74">/libexec/android-sdk&amp;#34;\
&lt;/span>&lt;span style="color:#e6db74"> --set tunnelvr_EXPORT_TEMPLATES &amp;#34;&lt;/span>&lt;span style="color:#e6db74">${&lt;/span>export-templates&lt;span style="color:#e6db74">}&lt;/span>&lt;span style="color:#e6db74">/templates&amp;#34; \
&lt;/span>&lt;span style="color:#e6db74"> --set tunnelvr_DEBUG_KEY &amp;#34;&lt;/span>&lt;span style="color:#e6db74">${&lt;/span>debugKey&lt;span style="color:#e6db74">}&lt;/span>&lt;span style="color:#e6db74">&amp;#34;
&lt;/span>&lt;span style="color:#e6db74"> &amp;#39;&amp;#39;&lt;/span>;
};
&lt;span style="color:#f92672">...&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;p>This code was a lot of fun to make.&lt;/p>
&lt;p>&lt;code>debugKey&lt;/code> is a simple derivation which uses &lt;code>keytool&lt;/code> to generate a key, which
is placed in the Nix Store. We use &lt;code>wrapProgram&lt;/code> to set the &lt;code>tunnelvr_DEBUG_KEY&lt;/code>
variable to the result of the nix expression &lt;code>${debugKey}&lt;/code>. That results in a
string like &lt;code>/nix/store/1pw8k0vl0miqv7kjxkyfk1qq5rywb4rs-debugKey&lt;/code>, which Godot
will now use thanks to our patching. &lt;code>export-templates&lt;/code> is the same way, and our
&lt;code>tunnelvr_ANDROID_SDK&lt;/code> variable also trivially fetches the android sdk from
&lt;code>androidenv.androidPkgs_9_0.androidsdk&lt;/code> in Nixpkgs.&lt;/p>
&lt;p>&lt;code>version&lt;/code> is an attribute set which contains the major, minor, patch and status,
which allows me to construct a string like &lt;code>3.4-stable&lt;/code> by reading and applying
regex to the
&lt;a href="https://github.com/godotengine/godot/blob/3.4-stable/version.py">version.py&lt;/a>
file that exists in the Godot source code. This allows me to fetch the
export-templates in a way that doesn&amp;rsquo;t force me to hardcode the URL to a string.&lt;/p>
&lt;h2 id="defining-the-devshell">Defining the devShell&lt;/h2>
&lt;p>We now have our solution. If I want to make this as simple as one command, &lt;code>nix develop&lt;/code>, I have to define a &lt;code>devShell&lt;/code> in the &lt;code>flake.nix&lt;/code> of this repository.&lt;/p>
&lt;div class="highlight">&lt;pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-nix" data-lang="nix">&lt;span style="color:#f92672">...&lt;/span>
devShell &lt;span style="color:#960050;background-color:#1e0010">=&lt;/span> forAllSystems (system:
&lt;span style="color:#66d9ef">let&lt;/span> pkgs &lt;span style="color:#f92672">=&lt;/span> nixpkgsFor&lt;span style="color:#f92672">.&lt;/span>&lt;span style="color:#e6db74">&amp;#34;&lt;/span>&lt;span style="color:#e6db74">${&lt;/span>system&lt;span style="color:#e6db74">}&lt;/span>&lt;span style="color:#e6db74">&amp;#34;&lt;/span>;
&lt;span style="color:#66d9ef">in&lt;/span> pkgs&lt;span style="color:#f92672">.&lt;/span>mkShell {
buildInputs &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#66d9ef">with&lt;/span> pkgs; [ my-godot-wrapped jre_headless ];
});
&lt;span style="color:#f92672">...&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;p>This defines a shell which contains &lt;code>my-godot-wrapped&lt;/code> and &lt;code>jre_headless&lt;/code>. Turns
out that some of the Android SDK commands have an undeclared dependency on Java,
such as &lt;code>keytool&lt;/code>, which otherwise crash if it is not present.&lt;/p>
&lt;h1 id="the-result">The result&lt;/h1>
&lt;p>Now that I&amp;rsquo;ve patched Godot in this fashion, if you&amp;rsquo;re developing TunnelVR, all
you have to do is &lt;code>nix develop&lt;/code>, and you can export APKs from Godot. No extra
steps. This will work on any variety of Linux distribution, be it Ubuntu,
Alpine, Arch, it doesn&amp;rsquo;t matter as long as you have &lt;code>nix&lt;/code>.&lt;/p></content></item><item><title>Hypercore Beam - Break Through NAT With This One Weird Trick</title><link>https://blog.croughan.sh/posts/hyp-beam/</link><pubDate>Tue, 24 Aug 2021 01:51:58 +0100</pubDate><guid>https://blog.croughan.sh/posts/hyp-beam/</guid><description>hyp beam can be thought of as a drop-in replacement for nc, for those situations where you just can&amp;rsquo;t be bothered to set up a VPN or manually establish a path between two machines via traditional methods like port forwarding. It provides the user with a method of breaking through NAT and transferring data via the Hypercore protocol between two machines, peer to peer, anywhere in the world. Peer discovery happens via DHT/mDNS using a concept called Hyperswarm, not too dissimilar from what Bittorrent clients have always done; although its usage of mDNS is quite unique and cool.</description><content>&lt;p>&lt;code>hyp beam&lt;/code> can be thought of as a drop-in replacement for &lt;code>nc&lt;/code>, for those
situations where you just can&amp;rsquo;t be bothered to set up a VPN or manually
establish a path between two machines via traditional methods like port
forwarding. It provides the user with a method of breaking through NAT and
transferring data via the Hypercore protocol between two machines, peer to peer,
anywhere in the world. Peer discovery happens via DHT/mDNS using a concept
called &lt;a href="https://hypercore-protocol.org/guides/modules/hyperswarm/">Hyperswarm&lt;/a>,
not too dissimilar from what Bittorrent clients have always done; although its
usage of mDNS is quite unique and cool.&lt;/p>
&lt;p>Hypercore Beams are end to end encrypted. There&amp;rsquo;s no overhead that I can
measure, and it can be used directly in place of netcat. IP Address, network
conditions, network port, all cease to matter since with &lt;code>hyp&lt;/code> since we only
care about piping data between processes. A shared secret you pass to the
command which can be as simple as a set of words is used as an identifier, in
place of an IP address. So what are some of the things I use it for?&lt;/p>
&lt;h1 id="sending-zfs-datasets-around-the-internet">Sending ZFS datasets around the internet&lt;/h1>
&lt;p>&lt;img src="https://blog.croughan.sh/hyperzfs.png" alt="image">&lt;/p>
&lt;p>Usually, &lt;code>zfs send&lt;/code> requires LAN connectivity, or a VPN, which is a pain to
think about. Why think about where your machines are? With &lt;code>hyp beam&lt;/code> I can just
push and pull ZFS datasets through an encrypted tunnel without caring where I am
in the world.&lt;/p>
&lt;pre>&lt;code>## Machine 1
zfs send eggshells/data | hyp beam &amp;quot;secret words&amp;quot;
## Machine 2
hyp beam &amp;quot;secret words&amp;quot; | zfs recv zpool/data
&lt;/code>&lt;/pre>&lt;p>Machine 1 pipes &lt;code>zfs send&lt;/code> into &lt;code>hyp beam&lt;/code> which chooses a secret. This secret
can be any string in &lt;code>hyp beam &amp;quot;&amp;lt;secret&amp;gt;&amp;quot;&lt;/code>. This secret is then used as an
identifier, it is all you need to establish communication between the two
machines. Machine 2 then pipes the output of &lt;code>hyp beam &amp;quot;&amp;lt;secret&amp;gt;&amp;quot;&lt;/code> into &lt;code>zfs recv&lt;/code>. How simple is that?&lt;/p>
&lt;p>Sidenote: I call one of my pools &lt;code>eggshells&lt;/code> because often whenever I interact
with it, it&amp;rsquo;s like &lt;a href="https://dictionary.cambridge.org/dictionary/english/walk-be-on-eggshells">walking on
eggshells.&lt;/a>&lt;/p>
&lt;h1 id="video-streams-over-the-wan">Video streams over the WAN&lt;/h1>
&lt;p>&lt;img src="https://blog.croughan.sh/hypermpv.png" alt="image">&lt;/p>
&lt;p>Sending Video over &lt;code>hyp beam&lt;/code> is surprisingly practical. It&amp;rsquo;s a good
demonstrator of how &lt;code>hyp beam&lt;/code> can be used in place of &lt;code>nc&lt;/code>. Once you realize
that this is just a peer to peer link to send data through with no overhead, it
ceases to be impressive. The ease of use is what is amazing.&lt;/p>
&lt;p>The following will use fancy bash wankery to create two FIFO pipes with which to
transmit video data from &lt;code>ffmpeg&lt;/code> through. Such that two clients can watch the
video via Netcat, or anywhere in the world via Hypercore.&lt;/p>
&lt;h2 id="with-netcat">With Netcat&lt;/h2>
&lt;p>This requires you to know the IP address of the machine, and have a direct
connection via LAN/VPN.&lt;/p>
&lt;pre>&lt;code>## Sending
ffmpeg -vcodec mjpeg -i /dev/video0 -f avi - | tee -- &amp;gt;(nc -l 1234) &amp;gt;(nc -l 5678) &amp;gt; /dev/null; wait
## Recieving
# Client 1
nc 127.0.0.1 1234 | mpv -
# Client 2
nc 127.0.0.1 5678 | mpv -
&lt;/code>&lt;/pre>&lt;h2 id="with-hypercore-beam">With Hypercore Beam&lt;/h2>
&lt;p>This does not require knowing the IP address of a machine, or having a direct
connection via LAN/VPN. It will work between two machines anywhere in the world
and is likely to succeed even when it encounters firewalls. The port also does
not matter, because we only care about the data being piped into a process.&lt;/p>
&lt;pre>&lt;code>## Sending
ffmpeg -vcodec mjpeg -i /dev/video0 -f avi - | tee -- &amp;gt;(hyp beam &amp;quot;1234&amp;quot;) &amp;gt;(hyp beam &amp;quot;5678&amp;quot;) &amp;gt; /dev/null; wait
## Recieving
# Client 1
hyp beam &amp;quot;1234&amp;quot; | mpv -
# Client 2
hyp beam &amp;quot;5678&amp;quot; | mpv -
&lt;/code>&lt;/pre>&lt;h1 id="sharing-files-with-unix-friends">Sharing files with UNIX friends&lt;/h1>
&lt;p>Sometimes I want to share folders or files with friends that are on macOS/Linux.
Usually I would use &lt;code>magic-wormhole&lt;/code> for this, but one of the annoying things
about that program is that if you want to send a folder it first has to be
zipped. That &lt;code>zip&lt;/code> process can take a very long time and requires you to have as
much RAM as the filesize you are trying to send. It also doesn&amp;rsquo;t even give you
as good of a compression ratio as gzip. Since &lt;code>hyp beam&lt;/code> only cares about piping
data, we can make up our own method of sending the folder, by using &lt;code>tar&lt;/code>.&lt;/p>
&lt;pre>&lt;code># Sender (Sending the Folder)
tar cf - &amp;lt;folder-name&amp;gt; | hyp beam &amp;quot;secret&amp;quot;
# Receiver (Receiving the Folder)
hyp beam &amp;quot;secret&amp;quot; | tar xvf -
&lt;/code>&lt;/pre>&lt;p>You could easily invent shell aliases such as &lt;code>send-to-matt&lt;/code> or &lt;code>receive-matt&lt;/code>
ready to pack/unpack files, hiding the &lt;code>tar&lt;/code> command from sight such that this
feels like a proper application for sending and recieving files rather than
having to remember the &lt;code>tar&lt;/code> syntax each time.&lt;/p>
&lt;h1 id="what-will-you-use-it-for">What will you use it for?&lt;/h1>
&lt;p>&lt;a href="https://hypercore-protocol.org/protocol/">https://hypercore-protocol.org/protocol/&lt;/a>&lt;/p></content></item><item><title>NixOS + the Worst UEFI ever (S5520UR)</title><link>https://blog.croughan.sh/posts/nixos-on-s5520ur/</link><pubDate>Sun, 15 Aug 2021 03:51:17 +0100</pubDate><guid>https://blog.croughan.sh/posts/nixos-on-s5520ur/</guid><description>If you read the Wikipedia Page on UEFI you will notice there are a few things missing.
The first thing that is missing is names. The second is the word &amp;lsquo;engineer&amp;rsquo;. Did humans make this? Is any one responsible? Who is to blame? UEFI was designed by a comittee, so no one can be held accountable.
More digging tells me that UEFI was developed by over 140 technology companies as part of a UEFI consortium.</description><content>&lt;p>If you read &lt;a href="https://en.wikipedia.org/wiki/Unified_Extensible_Firmware_Interface">the Wikipedia Page on
UEFI&lt;/a> you
will notice there are a few things missing.&lt;/p>
&lt;p>The first thing that is missing is names. The second is the word &amp;lsquo;engineer&amp;rsquo;. Did
humans make this? Is any one responsible? Who is to blame? UEFI was designed by
a comittee, so no one can be held accountable.&lt;/p>
&lt;p>More digging tells me that UEFI was &lt;a href="https://uefi.org/members">developed by over 140 technology companies
as part of a UEFI consortium&lt;/a>. Is there any wonder
nobody can decide how to implement it? Especially when Facebook (!?!?) have a
seat at the table. Some implementations hardcode paths to
&lt;code>/EFI/Microsoft/Boot/bootmgfw.efi&lt;/code>, probably because some of these companies
only care about Windows and screwed it up for the rest of us.&lt;/p>
&lt;p>The first machine I ever ran Linux on was an &lt;a href="https://ark.intel.com/content/www/us/en/ark/products/36456/intel-server-board-s5520ur.html">Intel Server Board
S5520UR&lt;/a>.
It taught me Linux, I had no experience prior to it, it has taught me a lot of
things, but today it taught me a little bit about UEFI. Intel gets the most
credit for creating UEFI in various articles, yet this board has one of the most
broken UEFI implementations (irony?). For 3 years, I gave up trying to install
anything in EFI mode with this board, thinking it was impossible. But today, I
decided I wasn&amp;rsquo;t content with that, so went on an 8 hour mission, mostly due to
the time it takes to POST!&lt;/p>
&lt;p>Some facts:&lt;/p>
&lt;ul>
&lt;li>The board takes 2 minutes to initialize and POST, which is much longer than it takes
to boot Linux.&lt;/li>
&lt;li>It cost me only £50~ from eBay.&lt;/li>
&lt;li>It was a cheap way to get 24 threads&lt;/li>
&lt;li>The processor(s) (Xeon x5675) cost only £10~&lt;/li>
&lt;li>It probably isn&amp;rsquo;t worth the effort, but whatever.&lt;/li>
&lt;/ul>
&lt;h1 id="the-problem">The problem&lt;/h1>
&lt;p>Attempts to install any OS in EFI mode results in the BIOS of the S5520UR
seemingly being unable to see the &lt;code>.efi&lt;/code> file on the disk, meaning you can&amp;rsquo;t
really boot anything if you try, since it won&amp;rsquo;t show up in the Boot Menu or Boot
Manager of the BIOS.&lt;/p>
&lt;p>For some reason, the NixOS Installer Media shows up in the BIOS as &lt;code>EFI:Corsair Voyager SliderX2000AHD(Part1,Sig9FB6382F&lt;/code> which is correct. I can&amp;rsquo;t replicate
this behavior via the installation of any OS. Only this installer media seems to
have the correct configuration to be auto-detected by the S5520UR&amp;rsquo;s UEFI
implementation when flashed to a USB flash drive.&lt;/p>
&lt;p>Upon a quick Google you can &lt;a href="https://www.reddit.com/r/servers/comments/ar3k6y/trying_to_install_windows_to_an_intel_s5520ur/">this post on
Reddit&lt;/a>
entitled &lt;em>&amp;ldquo;Trying to install Windows to an Intel S5520UR board with RAID0 SAS
array. Gets stuck on &amp;ldquo;Copying files (0%)&amp;rdquo;. Help?&amp;quot;&lt;/em>&lt;/p>
&lt;blockquote>
&lt;p>I was able to fix the problem. &lt;strong>Don&amp;rsquo;t try to install Windows in EFI mode only&lt;/strong>,
this causes the freeze. I guess these kind of servers are just too old.&lt;/p>
&lt;/blockquote>
&lt;p>They also gave up. Unacceptable.&lt;/p>
&lt;p>So, what can it be? I happen to be trying to install NixOS, which gives me an
advantage in both trying out various bootloader configurations and explaining
what I tried.&lt;/p>
&lt;h1 id="first-attempts">First attempts&lt;/h1>
&lt;p>First, I try systemd-boot:&lt;/p>
&lt;div class="highlight">&lt;pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-nix" data-lang="nix">{
boot&lt;span style="color:#f92672">.&lt;/span>loader&lt;span style="color:#f92672">.&lt;/span>systemd-boot&lt;span style="color:#f92672">.&lt;/span>enable &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#66d9ef">true&lt;/span>;
}
&lt;/code>&lt;/pre>&lt;/div>&lt;p>&lt;a href="https://www.dictionary.com/browse/nix">Nix&lt;/a>. The disk does not appear as a bootable device in the BIOS.&lt;/p>
&lt;p>What about systemd-boot, but this time giving it the ability to touch variables in
&lt;code>/sys/firmware/efi/efivars/&lt;/code>?&lt;/p>
&lt;div class="highlight">&lt;pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-nix" data-lang="nix">{
boot&lt;span style="color:#f92672">.&lt;/span>loader &lt;span style="color:#f92672">=&lt;/span> {
systemd-boot&lt;span style="color:#f92672">.&lt;/span>enable &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#66d9ef">true&lt;/span>;
canTouchEfiVariables &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#66d9ef">true&lt;/span>;
};
}
&lt;/code>&lt;/pre>&lt;/div>&lt;p>This halts the CPU. So what about GRUB?&lt;/p>
&lt;div class="highlight">&lt;pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-nix" data-lang="nix">{
boot&lt;span style="color:#f92672">.&lt;/span>loader &lt;span style="color:#f92672">=&lt;/span> {
efi &lt;span style="color:#f92672">=&lt;/span> {
canTouchEfiVariables &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#66d9ef">false&lt;/span>;
};
grub &lt;span style="color:#f92672">=&lt;/span> {
efiSupport &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#66d9ef">true&lt;/span>;
device &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#e6db74">&amp;#34;nodev&amp;#34;&lt;/span>;
};
};
}
&lt;/code>&lt;/pre>&lt;/div>&lt;p>The same result. No &lt;code>EFI:&amp;lt;disk&amp;gt;&lt;/code> option in the BIOS for the installation. The
CPU still halts if &lt;code>boot.loader.efi.canTouchEfiVariables = true;&lt;/code>&lt;/p>
&lt;p>I saw &lt;a href="https://nixos.wiki/wiki/Bootloader#Wrangling_recalcitrant_UEFI_implementations">this
section&lt;/a>
of the nixos.wiki on &amp;ldquo;Wrangling recalcitrant UEFI implementations&amp;rdquo; and decided
to try and copy the &lt;code>.efi&lt;/code> file for systemd-boot from
&lt;code>/boot/EFI/systemd/systemd-bootx64.efi&lt;/code> to &lt;code>/EFI/Microsoft/Boot/bootmgfw.efi&lt;/code>. I
was quite smug and hopeful about this one, but still, it did not work. But it
would have been an awesome hack if it did.&lt;/p>
&lt;h1 id="refind">rEFInd&lt;/h1>
&lt;p>The NixOS installer comes with a tool called rEFInd when booted in EFI mode. If
I select and use it, it successfully detects my previous attempts, be it GRUB or
systemd-boot, and successfully allows me to boot those bootloaders in EFI mode.
Now it&amp;rsquo;s getting interesting.&lt;/p>
&lt;h1 id="getting-closer">Getting Closer&lt;/h1>
&lt;p>There is a section in the nixos.wiki that mentions an interesting option that
I&amp;rsquo;ve never seen before, called &lt;code>boot.loader.grub.efiInstallAsRemovable&lt;/code>. I
decide to try it out, but I still get the same result. However, I find &lt;a href="https://github.com/NixOS/nixpkgs/pull/35528">this
pull request&lt;/a> from NixOS
contributor &amp;lsquo;samueldr&amp;rsquo; which reiterates some of my issues with EFI boot. I
believed it was possible that this option might have some impact on it.&lt;/p>
&lt;p>I waste no time. I enter the NixOS Matrix Channel and tag @samueldr and describe
the issue exactly. He informs me that that pull request has nothing to do with
my problem, but that my UEFI implementation is buggy if this doesn&amp;rsquo;t work as a
&amp;ldquo;fallback&amp;rdquo;. It turns out that all UEFI implementations should fallback to a
default EFI program when present; which in this case should be the GRUB I just
installed with &lt;code>efiInstallAsRemovable = true;&lt;/code>.&lt;/p>
&lt;h1 id="epiphany">Epiphany&lt;/h1>
&lt;p>Finally. We discover that there is an option in the BIOS named &amp;ldquo;Add new boot
option&amp;rdquo;. It turns out that this must be manually invoked and passed an absolute
path to the location of the &lt;code>.efi&lt;/code> file on disk if you ever hope to boot
anything with EFI.&lt;/p>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th>Step 1&lt;/th>
&lt;th>Step 2&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>&lt;img src="https://blog.croughan.sh/uefi-bios1.webp" alt="">&lt;/td>
&lt;td>&lt;img src="https://blog.croughan.sh/uefi-bios2.webp" alt="">&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;p>So I do it, I label it &lt;code>maybe-nixos&lt;/code>, I give it a path to the &lt;code>.efi&lt;/code> file
&lt;code>\efi\boot\bootx64.efi&lt;/code>. Then, I try to boot it. It boots without the
assistance of rEFInd.&lt;/p>
&lt;h1 id="takeaway">Takeaway&lt;/h1>
&lt;p>The S5520UR:&lt;/p>
&lt;ul>
&lt;li>Won&amp;rsquo;t use fallback locations&lt;/li>
&lt;li>Halts the CPU when &lt;code>/sys/firmware/efi/efivars/&lt;/code> is poked&lt;/li>
&lt;li>Apparently requires completely manual setup and configuration of the EFI boot via human fingers&lt;/li>
&lt;li>Is hot trash.&lt;/li>
&lt;/ul>
&lt;p>The only documentation I can find for this that could possibly help a normal
user of the motherboard is buried in the &lt;a href="https://techlibrary.hpe.com/docs/iss/proliant_uefi/UEFI_TM_030617/s_adding_boot_option.html">Aptio HPE
documentation&lt;/a>&lt;/p></content></item><item><title>My Frustrating Arch Install (De-Antergosifying)</title><link>https://blog.croughan.sh/posts/lustrating-arch/</link><pubDate>Wed, 11 Nov 2020 23:25:09 +0000</pubDate><guid>https://blog.croughan.sh/posts/lustrating-arch/</guid><description>lustrate
/ˈlʌstreɪt/
verb
purify by expiatory sacrifice, ceremonial washing, or some other ritual action. &amp;ldquo;a soul lustrated in the baptismal waters&amp;rdquo;
The Past (Thu 21 May 23:26:00 GMT 2020) 2 years ago, in 2018, I began using Linux for real. My distribution of choice was Antergos, an &amp;lsquo;easy button&amp;rsquo; Arch installer that was really popular at the time. The first package I added post-install apparently was synergy, a package to share my mouse/keyboard with my still-existing Windows 10 machine:</description><content>&lt;blockquote>
&lt;p>lustrate&lt;br>
/ˈlʌstreɪt/&lt;br>
&lt;em>verb&lt;/em>&lt;br>
purify by expiatory sacrifice, ceremonial washing, or some other ritual action.
&lt;em>&amp;ldquo;a soul lustrated in the baptismal waters&amp;rdquo;&lt;/em>&lt;/p>
&lt;/blockquote>
&lt;h1 id="the-past-thu-21-may-232600-gmt-2020">The Past (Thu 21 May 23:26:00 GMT 2020)&lt;/h1>
&lt;p>2 years ago, in 2018, I began using Linux for real. My distribution of choice
was &lt;a href="https://en.wikipedia.org/wiki/Antergos">Antergos&lt;/a>, an &amp;lsquo;easy button&amp;rsquo; Arch
installer that was really popular at the time. The first package I added
post-install apparently was &lt;code>synergy&lt;/code>, a package to share my mouse/keyboard with
my still-existing Windows 10 machine:&lt;/p>
&lt;pre>&lt;code>matthew@thinkpad ~ $ head -n 3 /var/log/pacman.log
[2018-05-21 23:26] [PACMAN] Running 'pacman -S synergy'
[2018-05-21 23:26] [ALPM] transaction started
[2018-05-21 23:26] [ALPM] installed synergy (1.8.8-3)
&lt;/code>&lt;/pre>&lt;p>Little did I know that by choosing to use Antergos, I had already &lt;strong>infected my
future.&lt;/strong>&lt;/p>
&lt;h2 id="the-now-thu-12-nov-053830-gmt-2020">The Now (Thu 12 Nov 05:38:30 GMT 2020):&lt;/h2>
&lt;p>It&amp;rsquo;s 5AM. I have work tomorrow. What better way to spend my time than debugging
this crap? I love it.&lt;/p>
&lt;div class="collapsable-code">
&lt;input id="1" type="checkbox" checked />
&lt;label for="1">
&lt;span class="collapsable-code__language">PACMAN&lt;/span>
&lt;span class="collapsable-code__title">Full Output&lt;/span>
&lt;span class="collapsable-code__toggle" data-label-expand="Show" data-label-collapse="Hide">&lt;/span>
&lt;/label>
&lt;pre class="language-PACMAN" >&lt;code>
matthew@thinkpad ~ $ sudo pacman -Syu
:: Synchronising package databases...
core is up to date
extra is up to date
community is up to date
multilib is up to date
:: Starting full system upgrade...
:: Replace pygobject-devel with extra/python-gobject? [Y/n] y
:: Replace user-manager with extra/plasma-desktop? [Y/n] y
:: Replace xorg-luit with extra/luit? [Y/n] y
resolving dependencies...
looking for conflicting packages...
error: failed to prepare transaction (could not satisfy dependencies)
:: removing xorg-luit breaks dependency &amp;#39;xorg-luit&amp;#39; required by antergos-common-meta
:: removing user-manager breaks dependency &amp;#39;user-manager&amp;#39; required by antergos-kde-meta
&lt;/code>&lt;/pre>
&lt;/div>
&lt;p>&lt;code>:: removing xorg-luit breaks dependency 'xorg-luit' required by antergos-common-meta&lt;/code>&lt;/p>
&lt;p>&lt;code>:: removing user-manager breaks dependency 'user-manager' required by antergos-kde-meta&lt;/code>&lt;/p>
&lt;p>&lt;em>Agony.&lt;/em>&lt;/p>
&lt;p>&lt;a href="https://itsfoss.com/antergos-linux-discontinued/">When Antergos discontinued in May
2019&lt;/a>, I removed their mirrors
from &lt;code>/etc/pacman.conf&lt;/code>, which should have been enough. Everything had been fine
until now.&lt;/p>
&lt;h4 id="the-problem">The problem?&lt;/h4>
&lt;ol>
&lt;li>
&lt;p>The now dead and unmaintained
&lt;a href="https://wiki.archlinux.org/index.php/Meta_package_and_package_group">meta-package&lt;/a>
is causing &lt;a href="https://en.wikipedia.org/wiki/Dependency_hell">dependency hell&lt;/a> since
I did not remove it when Antergos died.&lt;/p>
&lt;/li>
&lt;li>
&lt;p>My decision to use Antergos has screwed me 2 years later.&lt;/p>
&lt;/li>
&lt;li>
&lt;p>I should have moved over to NixOS a long time ago.&lt;/p>
&lt;/li>
&lt;/ol>
&lt;h4 id="the-solution">The solution?&lt;/h4>
&lt;ol>
&lt;li>Simply remove the meta packages via &lt;code>pacman -Rdd&lt;/code>&lt;/li>
&lt;/ol>
&lt;pre>&lt;code>matthew@thinkpad ~ $ sudo pacman -Rdd antergos-kde-meta antergos-common-meta
Package (2) Old Version Net Change
antergos-common-meta 1.5-1 0.00 MiB
antergos-kde-meta 1.1-1 0.00 MiB
Total Removed Size: 0.01 MiB
:: Do you want to remove these packages? [Y/n]
&lt;/code>&lt;/pre>&lt;h4 id="the-result">The result?&lt;/h4>
&lt;p>🕒 1 wasted hour.&lt;/p>
&lt;p>I did not know what meta-packages were, or the consequences of removing them.&lt;/p>
&lt;p>I can now update my Arch system. Hopefully there is no more Antergos cruft still
lingering in my system.&lt;/p>
&lt;p>Everything will be fine going forward, as long as:&lt;/p>
&lt;ul>
&lt;li>Power isn&amp;rsquo;t lost during upgrade&lt;/li>
&lt;li>I do not &lt;code>^C&lt;/code> the upgrade at an inopportune time&lt;/li>
&lt;li>Creation of the initramfs succeeds (&lt;a href="https://bugs.archlinux.org/task/54918">it&amp;rsquo;s weird
sometimes&amp;hellip;&lt;/a>)&lt;/li>
&lt;li>I do not run out of disk space&lt;/li>
&lt;/ul>
&lt;p>If any item from this list isn&amp;rsquo;t met, the system can fail to boot. Since updates
are not atomic in any way. The only way to recover from such a situation is
&lt;code>arch-chroot&lt;/code> on an external recovery boot image such as the Arch install media
itself.&lt;/p>
&lt;p>This has happened to me too many times on this install, I count a total of 5
times. Though, if anything, this is a testament to how recoverable bad
situations can be on Linux if you have the
&lt;a href="https://docstore.mik.ua/orelly/unix3/upt/ch14_03.htm">know-how&lt;/a>&lt;/p>
&lt;p>Stuff like this really makes me want to move to NixOS, where these issues don&amp;rsquo;t
exist, or at least simple rollback from failure states is easy and built in.&lt;/p></content></item></channel></rss>