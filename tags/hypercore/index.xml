<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>hypercore on Matthew Croughan's Blog</title><link>https://blog.croughan.sh/tags/hypercore/</link><description>Recent content in hypercore on Matthew Croughan's Blog</description><generator>Hugo -- gohugo.io</generator><language>en-us</language><lastBuildDate>Tue, 24 Aug 2021 01:51:58 +0100</lastBuildDate><atom:link href="https://blog.croughan.sh/tags/hypercore/index.xml" rel="self" type="application/rss+xml"/><item><title>Hypercore Beam - Break Through NAT With This One Weird Trick</title><link>https://blog.croughan.sh/posts/hyp-beam/</link><pubDate>Tue, 24 Aug 2021 01:51:58 +0100</pubDate><guid>https://blog.croughan.sh/posts/hyp-beam/</guid><description>hyp beam can be thought of as a drop-in replacement for nc, for those situations where you just can&amp;rsquo;t be bothered to set up a VPN or manually establish a path between two machines via traditional methods like port forwarding. It provides the user with a method of breaking through NAT and transferring data via the Hypercore protocol between two machines anywhere in the world. Peer discovery happens via DHT/mDNS using a concept called Hyperswarm, not too dissimilar from what Bittorrent clients have always done; although its usage of mDNS is quite unique and cool.</description><content>&lt;p>&lt;code>hyp beam&lt;/code> can be thought of as a drop-in replacement for &lt;code>nc&lt;/code>, for those
situations where you just can&amp;rsquo;t be bothered to set up a VPN or manually
establish a path between two machines via traditional methods like port
forwarding. It provides the user with a method of breaking through NAT and
transferring data via the Hypercore protocol between two machines anywhere in
the world. Peer discovery happens via DHT/mDNS using a concept called
&lt;a href="https://hypercore-protocol.org/guides/modules/hyperswarm/">Hyperswarm&lt;/a>, not too
dissimilar from what Bittorrent clients have always done; although its usage of
mDNS is quite unique and cool.&lt;/p>
&lt;p>Hypercore Beams are end to end encrypted. There&amp;rsquo;s no overhead that I can
measure, and it can be used directly in place of netcat. IP Address, network
conditions, network port, all cease to matter since with &lt;code>hyp&lt;/code> since we only care
about piping data between processes. So what are some of the things I use it
for?&lt;/p>
&lt;h1 id="sending-zfs-datasets-around-the-internet">Sending ZFS datasets around the internet&lt;/h1>
&lt;p>&lt;img src="https://blog.croughan.sh/hyperzfs.png" alt="image">&lt;/p>
&lt;p>Usually, &lt;code>zfs send&lt;/code> requires LAN connectivity, or a VPN, which is a pain to
think about. Why think about where your machines are? With &lt;code>hyp beam&lt;/code> I can just
push and pull ZFS datasets through an encrypted tunnel without caring where I am
in the world.&lt;/p>
&lt;pre>&lt;code>## Machine 1
zfs send eggshells/data | hyp beam &amp;quot;secret words&amp;quot;
## Machine 2
hyp beam &amp;quot;secret words&amp;quot; | zfs recv zpool/data
&lt;/code>&lt;/pre>&lt;p>Machine 1 pipes &lt;code>zfs send&lt;/code> into &lt;code>hyp beam&lt;/code> which chooses a secret. This secret
can be any string in &lt;code>hyp beam &amp;quot;&amp;lt;secret&amp;gt;&amp;quot;&lt;/code>. Machine 2 then pipes the output of
&lt;code>hyp beam &amp;quot;&amp;lt;secret&amp;gt;&amp;quot;&lt;/code> into &lt;code>zfs recv&lt;/code>. How simple is that?&lt;/p>
&lt;p>Sidenote: I call one of my pools &lt;code>eggshells&lt;/code> because often whenever I interact
with it, it&amp;rsquo;s like &lt;a href="https://dictionary.cambridge.org/dictionary/english/walk-be-on-eggshells">walking on
eggshells.&lt;/a>&lt;/p>
&lt;h1 id="video-streams-over-the-wan">Video streams over the WAN&lt;/h1>
&lt;p>&lt;img src="https://blog.croughan.sh/hypermpv.png" alt="image">&lt;/p>
&lt;p>Sending Video over &lt;code>hyp beam&lt;/code> is surprisingly practical. It&amp;rsquo;s a good
demonstrator of how &lt;code>hyp beam&lt;/code> can be used in place of &lt;code>nc&lt;/code>. Once you realize
that this is just a peer to peer link to send data through with no overhead, it
ceases to be impressive. The ease of use is what is amazing.&lt;/p>
&lt;p>The following will use fancy bash wankery to create two FIFO pipes with which to
transmit video data from &lt;code>ffmpeg&lt;/code> through. Such that two clients can watch the
video via Netcat, or anywhere in the world via Hypercore.&lt;/p>
&lt;h2 id="with-netcat">With Netcat&lt;/h2>
&lt;p>This requires you to know the IP address of the machine, and have a direct
connection via LAN/VPN.&lt;/p>
&lt;pre>&lt;code>## Sending
ffmpeg -vcodec mjpeg -i /dev/video0 -f avi - | tee -- &amp;gt;(nc -l 1234) &amp;gt;(nc -l 5678) &amp;gt; /dev/null; wait
## Recieving
# Client 1
nc 127.0.0.1 1234 | mpv -
# Client 2
nc 127.0.0.1 5678 | mpv -
&lt;/code>&lt;/pre>&lt;h2 id="with-hypercore-beam">With Hypercore Beam&lt;/h2>
&lt;p>This does not require knowing the IP address of a machine, or having a direct
connection via LAN/VPN. It will work between two machines anywhere in the world
and is likely to succeed even when it encounters firewalls. The port also does
not matter, because we only care about the data being piped into a process.&lt;/p>
&lt;pre>&lt;code>## Sending
ffmpeg -vcodec mjpeg -i /dev/video0 -f avi - | tee -- &amp;gt;(hyp beam &amp;quot;1234&amp;quot;) &amp;gt;(hyp beam &amp;quot;5678&amp;quot;) &amp;gt; /dev/null; wait
## Recieving
# Client 1
hyp beam &amp;quot;1234&amp;quot; | mpv -
# Client 2
hyp beam &amp;quot;5678&amp;quot; | mpv -
&lt;/code>&lt;/pre>&lt;h1 id="sharing-files-with-unix-friends">Sharing files with UNIX friends&lt;/h1>
&lt;p>Sometimes I want to share folders or files with friends that are on macOS/Linux.
Usually I would use &lt;code>magic-wormhole&lt;/code> for this, but one of the annoying things
about that program is that if you want to send a folder it first has to be
zipped. That &lt;code>zip&lt;/code> process can take a very long time and requires you to have as
much RAM as the filesize you are trying to send. It also doesn&amp;rsquo;t even give you
as good of a compression ratio as gzip. Since &lt;code>hyp beam&lt;/code> only cares about piping
data, we can make up our own method of sending the folder, by using &lt;code>tar&lt;/code>.&lt;/p>
&lt;pre>&lt;code># Sender (Sending the Folder)
tar cf - &amp;lt;folder-name&amp;gt; | hyp beam &amp;quot;secret&amp;quot;
# Receiver (Receiving the Folder)
hyp beam &amp;quot;secret&amp;quot; | tar xvf -
&lt;/code>&lt;/pre>&lt;p>You could easily invent shell aliases such as &lt;code>send-to-matt&lt;/code> or &lt;code>receive-matt&lt;/code>
ready to pack/unpack files, hiding the &lt;code>tar&lt;/code> command from sight such that this
feels like a proper application for sending and recieving files rather than
having to remember the &lt;code>tar&lt;/code> syntax each time.&lt;/p>
&lt;h1 id="what-will-you-use-it-for">What will you use it for?&lt;/h1></content></item></channel></rss>